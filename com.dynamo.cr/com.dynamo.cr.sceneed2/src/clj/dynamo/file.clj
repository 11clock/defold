(ns dynamo.file
  "Functions to help developers load and save files"
  (:refer-clojure :exclude [load])
  (:require [clojure.java.io :as io]
            [internal.java :as j])
  (:import [java.io PipedOutputStream PipedInputStream]
           [com.google.protobuf TextFormat]
           [org.eclipse.core.internal.resources File]))

(defn- new-builder
  [class]
  (j/invoke-no-arg-class-method class "newBuilder"))

(defn protocol-buffer-loader
  [^java.lang.Class class f]
  (fn [project-state nm input-reader]
    (let [builder (new-builder class)]
      (TextFormat/merge input-reader builder)
      (f project-state nm (.build builder)))))

(defmulti message->node
  (fn [message & _] (class message)))

(extend File
  io/IOFactory
  (assoc io/default-streams-impl
         :make-input-stream
         (fn [x opts]
           (.getContents x))
         :make-output-stream
         (fn [x opts]
           (let [pipe (PipedOutputStream.)]
             (future (.setContents x (PipedInputStream. pipe) 0 nil))
             pipe))))

(doseq [[v doc]
       {#'new-builder
        "Dynamically construct a protocol buffer builder, given a class as a variable."

        #'protocol-buffer-loader
          "Create a new loader that knows how to read protocol buffer files in text format.

class is the Java class generated by the protoc compiler. It will probably be an inner class
of some top-level name. Instead of a '.' for the inner class name separator, use a '$'.

For example, the inner class called AtlasProto.Atlas in Java becomes AtlasProto$Atlas.

f is a function to call with the deserialised protocol buffer message. f must take two arguments, the
resource name and the immutable protocol buffer itself."

        #'message->node
          "This is an extensible function that you implement to help load a specific file
type. Most of the time, these will be created for you by the
dynamo.file.protobuf/protocol-buffer-converter macro.

Create an implementation by adding something like this to your namespace:

(defmethod message->node _message-classname_
  [_message-instance_ container container-target desired-output & {:as overrides}]
  (,,,) ;; implementation
)

You'll replace _message-classname_ with the Java class that matches the message
type to convert. The _message-instance_ argument will contain an instance of the
class specified in _message-classname_.

If the message instance contains other messages (as in the case of protocol buffers,
for example) then you should call message->node recursively with the same resource-name
and the child message.

When container is set, it means this node should be connected to the container. In that case,
container-target is the label to connect _to_ and desired-output is the label to connect
from. It is an error for a container to ask for a desired-output that doesn't exist on the
node being created by this function.

Overrides is a map of additional properties to set on the new node.

Given a resource name and message describing the resource,
create (and return?) a list of nodes."
          }]
  (alter-meta! v assoc :doc doc))


