local gravity = 1600
local max_fall_speed = 800
local max_slide_fall_speed = 300
local wall_friction = 0.3
local max_speed = 280
local jump_speed = 500
local walljump_speed = 400
local walljump_out_speed = 300

function init(self)
	msg.post(nil, "acquire_input_focus")
	msg.post("hero_camera.go#camera", "acquire_camera_focus")
	self.state = "idle"
	self.facing = "left"
	self.velocity = vmath.vector3()
	self.momentum = vmath.vector3()
	self.verticalspeed = vmath.vector3()
	self.input_vector = vmath.vector3()
	self.corr = vmath.vector3()
	self.groundcontact = false
	self.wallcontact = false
	self.wallcontact_normal = vmath.vector3()
	self.onladder = false
	
	-- Timers
	self.slide_timer = 0
	self.jump_timer = 0	
end

function update(self, dt)
	local prev_pos = go.get_position()
	
	-- Calculate smoothed movement.
	local target_movement = self.input_vector * max_speed
	if self.jump_timer <= 0 then
		if self.groundcontact then
			-- On ground
			self.momentum = vmath.lerp(0.10, self.momentum, target_movement)
		else
			-- In air
			self.momentum = vmath.lerp(0.05, self.momentum, target_movement)
		end
	else
		self.jump_timer = self.jump_timer - dt
	end
		
	-- Clamp the momentum
	if vmath.length(self.momentum) < 1 then
		self.momentum.x = 0
		self.momentum.y = 0
	end

	-- If we're not on a ladder we're ignoring the y momentum
	if self.onladder == false then
		self.momentum.y = 0
	end
	
	-- Apply gravity
	if self.wallcontact == true and self.verticalspeed.y < 0 then
		self.verticalspeed.y = self.verticalspeed.y - gravity * wall_friction * dt
	else
		self.verticalspeed.y = self.verticalspeed.y - gravity * dt
	end
	
	-- Cap speed 
	if self.verticalspeed.y < -max_fall_speed then
		self.verticalspeed.y = -max_fall_speed
	end
	if self.wallcontact == true and self.verticalspeed.y < -max_slide_fall_speed then
		-- Slide down vertical walls
		self.verticalspeed.y = -max_slide_fall_speed
	end
	
	-- Update position and calculate velocity
	local move_offset = (self.momentum + self.verticalspeed) * dt
	local new_pos = go.get_position() + move_offset
	self.velocity = new_pos - prev_pos
    go.set_position(new_pos)

	animate(self)
    
	-- Reset values
	self.corr = vmath.vector3()
	self.input_vector = vmath.vector3()
	self.groundcontact = false
	
	if self.slide_timer <= 0 then
		self.wallcontact = false
	else
		self.slide_timer = self.slide_timer - dt
	end
end

function animate(self)
	-- Put the character in the right animation state
	local prevstate = self.state
	
	if self.momentum.x > 0 then
		self.facing = "right"
	elseif self.momentum.x < 0 then
		self.facing = "left"
	end	
	
	if self.groundcontact then
		if math.abs(self.momentum.x) > 30 then
			self.state = "run"
		else
			self.state = "idle"
		end
	else
		-- No ground contact
		if self.verticalspeed.y > 0 then
			self.state = "jump"
		else
			self.state = "fall"
		end
	end
    
    -- State changed
    if self.state ~= prevstate then
    	anim = self.state .. "_" .. self.facing
    	msg.post("#sprite2", "play_animation2", {id = hash(anim)})
    end
end


function on_message(self, message_id, message, sender)
    if message_id == hash("contact_point_response") then
    
--    	msg.post("@render:", "draw_text", {position = vmath.vector3(200, 200, 0), text = "Normal: " .. message.normal})
--    	msg.post("@render:", "draw_text", {position = vmath.vector3(200, 250, 0), text = "Distance: " .. message.distance})
    	
		-- Correct the position based on contact points. We're getting 2 contact points since
		-- we're using a polygon collision shape for the hero. self.corr helps us deal with it.
		local proj = vmath.dot(self.corr, message.normal)
		local comp = (message.distance - proj) * message.normal
		self.corr = self.corr + comp
		-- Move out of collision
		go.set_position(go.get_position() + comp)
		if math.abs(message.normal.x) > math.abs(message.normal.y) then
			if message.normal.x * self.velocity.x < 0 then
				self.wallcontact = true
				self.wallcontact_normal = message.normal
				self.momentum.x = 0
				self.slide_timer = 0.15
			end
			
		else
			if message.normal.y * self.velocity.y < 0 then
				self.verticalspeed.y = 0
			end
			
			if message.normal.y > 0 then
				self.groundcontact = true
			end
		end
    end
end

function on_input(self, action_id, action)
    if action_id == hash("left") then
		self.input_vector = self.input_vector + vmath.vector3(-action.value, 0, 0) 
   	elseif action_id == hash("right") then
  		self.input_vector = self.input_vector + vmath.vector3(action.value, 0, 0)
	elseif action_id == hash("up") then
   		self.input_vector = self.input_vector + vmath.vector3(0, action.value, 0)
    elseif action_id == hash("down") then
   		self.input_vector = self.input_vector + vmath.vector3(0, -action.value, 0)
 	elseif action_id == hash("jump") and action.pressed then
 		-- The jump timer disables input for a little while
 		self.jump_timer = 0.2
 		if self.groundcontact == true then
	 		self.verticalspeed.y = jump_speed
	 	elseif self.wallcontact == true then
	 		-- Jump off wall
	 		self.verticalspeed.y = walljump_speed
	 		self.momentum = walljump_out_speed * self.wallcontact_normal
	 	end
	end
   	
	-- Map the square coordinates to circular.
--	self.input_vector.x = self.input_vector.x * math.sqrt(1 - 0.5 * self.input_vector.y * self.input_vector.y)
--	self.input_vector.y = self.input_vector.y * math.sqrt(1 - 0.5 * self.input_vector.x * self.input_vector.x)	
end

function on_reload(self)
	msg.post(nil, "idle")
end
