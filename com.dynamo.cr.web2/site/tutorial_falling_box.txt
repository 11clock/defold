Tutorial: Falling Box
=====================
:author:    Defold Team <info@defold.se>
:max-width: 45em
:numbered:
:website:   http://www.defold.se

:template:  Tutorial: Falling Box
:project:   My Falling Box
:branch:    my_branch

Overview
--------
This tutorial explains how to put together a simulation consisting of a box that falls down
onto the ground and produces impact sound effects.

image:images/falling_box/final_application.png[A screen shot of the final application when the tutorial is completed]

Here is a brief description of the format used in this tutorial:

[grid="none", frame="none", width="75%"]
|============================================================================================
|*bold*   |user input, such as menu options, buttons and short-cut keys.
|'italic' |Defold-specific terms and user interface names, such as different views and fields
|+mono+   |user content, such as file names and user specified values.
|============================================================================================

If you haven't already, please http://cr.defold.com/downloads/cr-editor/1.0[download the editor].

NOTE: This tutorial contains mouse and keyboard input specific to Windows and Linux.
If you use Mac, *right-click* means *Ctrl-click* and the *Cmd*-button
should be used instead of *Ctrl* for keyboard shortcuts.

Creating the Project
--------------------
Start by creating a new project through the dashboard at the website.

image:images/falling_box/new_project.png[The form to create new projects on the website]

Give it a fitting name, e.g. +{project}+, and optionally a fitting description as well.
Select +{template}+ as template for the project.
This will provide default settings for rendering and input, as well as assets for graphics and sound.
Click *Create Project*.

Connecting to the Project
-----------------------
The Defold editor remotely connects to the Defold server, which stores all project resources as
well as the pipeline to compile the content into runtime files.

Connect the editor to the project you created by selecting *File > Connect*.

image:images/falling_box/connect_project.png[Connecting to a project]

Choose the project you created and click *Next >*.

image:images/falling_box/connect_branch.png[Connecting to a branch]

Create a new branch called +{branch}+ and click *Finish*.

NOTE: Always use lower-case names without spaces for branch names.

Since the project was created from the +{template}+ template project, there are already a few resources
present.
Browse through the directories in the project explorer to familiarize yourself with the content.

NOTE: The +builtins+-directory contains resources available to any project, whatever template it was created from.

Setting up the simulation
-------------------------
Creating the Ground
~~~~~~~~~~~~~~~~~~~
*Right-click* the +logic+-directory and select *New > Game Object File*.

image:images/falling_box/new_go.png[Creating a new game object file]

Name it +ground.go+ and click *Finish*.

A game object consists of components.
Each component adds some kind of functionality to the game object, e.g. graphics,
collisions or logic in the form of scripts.
We want the ground to be visible so we need to add a 'Sprite'-component to it.

The buttons for adding and removing components are visible whenever a game object file is opened.
They are located in the top of the 'Components'-view.

image:images/falling_box/comp_view.png[The Components-view]

Click the button with a paper sheet and plus-sign (the center button), which opens
a dialog for creating an embedded resource.
When a resource is embedded, it simply means that the component information will be stored in
the game object file, as opposed to a referenced separate file (more on this later).

image:images/falling_box/new_sprite.png[Adding embedded components]

Select 'Sprite' and click *OK*.

image:images/falling_box/ground_sprite_props_empty.png[Properties for the ground sprite]

In the property view to the right, click the browse button in the 'texture' field.

image:images/falling_box/set_white_texture.png[Setting a texture through the resource browser]

Type +wh+ in the field, select +white.png+ and click *OK*.
The white texture consists of a singular white pixel and will simply serve to give the ground a white color
to distinguish it from the black background.

image:images/falling_box/ground_sprite_props.png[Properties for the ground sprite]

Also specify +960+ for 'width' and +100+ for 'height'.
The sprite will then cover the whole width of the application window, to simulate the ground.
Both 'tile_width' and 'tile_height' should be set to +1+, since the texture is only one pixel in size.
Save the file.

The ground also needs collision.
This is handled by the 'Collision Object'-component, which also handles all other
physical interaction.
The actual shape of the 'Collision Object' is defined by a separate resource type called
'Convex Shape'.
The shape is then bound to the 'Collision Object'.
We will begin by creating a new 'Convex Shape'.
*Right-click* the +logic+-directory and select *New > Convex Shape File*.
Name it +ground.convexshape+ and click *Finish*.

image:images/falling_box/ground_shape_props.png[Properties for the ground shape]

Leave the 'shape_type' set to +TYPE_BOX+.
The data-numbers specify the extents (half-size) of the box along x, y and z respectively.
Set x ('data 0') to +480+ and y ('data 1') to +50+.
Save the file.

Open the file +ground.go+ again. Click the paper-plus-button to add another embedded resource.
Select 'Collision Object' this time.

NOTE: You can use *Ctrl-Shift-R* to quickly open resources by searching their names incrementally.
To flip through the opened file tabs, use *Ctrl-Page Up* and *Ctrl-Page Down*.

image:images/falling_box/ground_co_props.png[Properties for the ground collision object]

Click the browse button in the field 'collision_shape'. Type +gr+, select the convex shape you
just created and click *OK*.
Since the ground should never move, set 'type' to +COLLISION_OBJECT_TYPE_STATIC+.
Set the 'mass' to +0+, since only dynamic collision objects can have a mass.

The 'group' and 'mask' are used to divide the collision objects into groups and define which groups should
collide with which.
The 'group' is a bit specifying which group the object belongs to.
The 'mask' is a bit-field specifying which groups the object will collide with.
Leave the 'group' set to +1+. Add +2+ to the 'mask' by first *right-clicking* the 'mask'-field.
If you add an incorrect mask field, you can *right-click* the added field and select *Remove*.

Save the file when done.

Creating the Box
~~~~~~~~~~~~~~~~
Create another convex shape and call it +box.convexshape+.

image:images/falling_box/box_shape_props.png[Properties for the box shape]

Set the extents to +25+ along x and y ('data 0' and 'data 1' respectively).
Save the file.

Create another game object and call it +box.go+.

image:images/falling_box/box_co_props.png[Properties for the ground game object]

Add a 'Collision Object'-component too and set the +box.convexshape+ you just created as its 'collision_shape'.
Since the box should start falling when simulation starts, leave 'collision_shape' set to +COLLISION_OBJECT_TYPE_DYNAMIC+.
Set its 'group' to +2+ and add +1+ to the 'mask'.
Since the ground has 'group' +1+ and collides with 'group' +2+ and the reverse hold for the box,
the two objects will collide during the simulation.

image:images/falling_box/box_sprite_props.png[Properties for the box collision object]

Add a 'Sprite'-component to it, but this time set the 'width' and 'height' to +50+.
Also, set 'tile_width' and 'tile_height' to +1+.

Save the file when done.

Putting it together
~~~~~~~~~~~~~~~~~~~
The file +main.collection+ in the +logic+-directory contains all the game objects that will
be created and simulated at startup.
Open the file and select the 'Outline'-view in the lower left area.
This view shows a hierarchical overview of the collection contents.

image:images/falling_box/outliner.png[Outline-view]

Select *Tools > Add GameObject* to add a game object to the collection.

image:images/falling_box/add_go.png[Adding a game object to a collection]

Type +gr+, select +ground.go+ and click *OK* to add the ground.
Since the camera is so close, the ground fills the entire view.
This will be taken care of later.
Add the +box.go+ game object too.

Now inspect the 'Outline'-view to see the hierarchy of objects and the files they are built from.
Select +ground.go+ and click the 'Properties'-tab in the lower right view.

image:images/falling_box/ground_go_props.png[Properties for the ground game object]

Open the 'worldTranslation'-item and set its x-component to +480+.

image:images/falling_box/box_go_props.png[Properties for the box game object]

Do the same for +box.go+, but also set its y-component to +200+.
This should place the box a bit above the ground.
Save the file.

It is currently hard to verify the positioning of the objects since the camera is off.
To focus the camera, select both the +ground.go+ and +box.go+ in the 'Outline'-view and
select *Tools > Frame Objects*.

image:images/falling_box/collection_framed.png[Properties for the ground game object]

Running the Application
-----------------------
Select *Tools > Launch > Build* to compile the content you created into runtime
files and launch the application.

image:images/falling_box/final_application.png[How the application should look at this stage]

You should now see the box falling down to the ground,
bounce slightly and then come to a stop. Hit *Esc* to quit the application.

Add Effects
-----------
Open +box.go+.
Click the button with a chain-link and a plus-sign to add a component from a referenced file.

image:images/falling_box/add_comp.png[Adding a referenced component]

Type +ti+ in the field, select +tin_thud.wav+ and click *OK*.

image:images/falling_box/comp_rename.png[Setting component id]

Hit *F2* to rename the component and change its id to +thud+.
Save the file.

Since we want to trigger the sound effect as a response to collisions, we need to add
'Script'-component to take care of that.

Add a new 'Script File' in the +logic+-directory and call it +box.script+.
The file is filled out with function stubs for every available callback-function.
At this time, we are only interested in +on_message+, so delete all the other functions.
You can also delete the comments (lines that begin with +--+) inside +on_message+.

The engine calls +on_message+ every time the script component receives a message.
This happens for example when a game object is in contact with another game object, provided
they both have collision object components which are tweaked to collide with each other.
What actually happens is that the collision objects broadcast the contact points to all
other components in the game objects involved in the collision.
To check for such a message, change the function to look like this and save the file:

----
function on_message(self, message_id, message, sender)
    -- check for contact points
    if message_id == hash("contact_point_message") then
        -- play sound
        msg.post("#thud", "play_sound")
    end
end
----

To play the sound when a contact point message has been received, we post a message called
+play_sound+ to the sound component +thud+ (recall that we changed its id before).
We do this every time a contact point message has been received.

Finally, we must add the script as a component to the game object for the script to be used.
Open +box.go+ again and add the script as a referenced component.
Save the file.

If you run the simulation now, you will notice that the impact effect sounds pretty bad,
like it is played too many times.

First of all, we only want the sound to play when the impact is hard enough.
To do this, we will check the +applied_impulse+ at the contact point.
Change +on_message+ to look like this:

----
function on_message(self, message_id, message, sender)
    -- check for contact points
    -- *and* that the impact in them is hard enough
    if message_id == hash("contact_point_message") and message.applied_impulse > 1 then
        -- play sound
        msg.post("#thud", "play_sound")
    end
end
----

The impact effect already sounds better.

Secondly, the objects can have multiple contact points for every collision, which makes the
sound over-dub itself.
We never want to play the sound several times within a short time period.
A timer variable will help us avoid this.
The variable will keep track of the time passed since the sound was last played.
As long as that time is short enough, we will not play the sound when contacts occur.

Start by adding +init+, which is called once when a game object is initialized (application start
in this case):

----
function init(self)
    -- the timer in its expired state (0)
    self.sfx_timer = 0
end
----

We now have stored a timer in the self-reference, so that we can access it from the other functions.
It is always guaranteed that +init+ is the first function to be called for every script.
To update the timer, we also add +update+, which is called once every frame by the engine.

----
function update(self, dt)
    -- if the timer has not expired yet
    if self.sfx_timer > 0 then
        -- decrement the timer with the passed time step
        self.sfx_timer = self.sfx_timer - dt
    end
end
----

Now our timer is ready to be used, so modify +on_message+ again:

----
function on_message(self, message_id, message, sender)
    -- check for contact points
    -- *and* that the impact in them is hard enough
    -- *and* that the timer has expired
    if message_id == hash("contact_point_message") and message.applied_impulse > 1 and self.sfx_timer <= 0 then
        -- play sound
        msg.post("#thud", "play_sound")
        -- wait 0.3 seconds before playing the sound again
        self.sfx_timer = 0.3
    end
end
----

Try running the application again and notice that the sound is played more appropriately now.

Synchronizing
-------------
To make your changes available to other users in the project, as well as obtaining any changes they have made,
you can synchronize your branch.
When synchronizing, the system will perform several tasks:

. First your changes are stored under a label (a commit) in your branch.
. Then your branch is updated with what has been changed on the master branch since the last time you synchronized.
. Then the master branch will be updated with any changes you have made on your branch.

When another user synchronizes, your changes will then be pushed to him/her from the master branch.

While working, you may have noticed the appearance of the files you have added or modified.
Any modified file is decorated with a pencil and the letter 'M' within square brackets.
Added files are decorated with plus-signs and the letter 'A'.
If you click the 'Changed Files'-tab (next to the 'Outline'-tab), there is also a summary of any changes you have made
since last synchronizing.

image:images/falling_box/changed_files.png[Changed Files view]

To synchronize your content now, select *File > Synchronize*.

image:images/falling_box/synchronize.png[Synchronize dialog]

Type in a fitting message for the changes you are about to push to the master branch, e.g. +Completed the tutorial.+.
Click *Commit*.
A confirmation dialog appears, click *OK*.
Your are now fully synchronized and can continue making other changes.

You Win!
--------

Congratulations, you have now completed the tutorial! Happy game developing!
