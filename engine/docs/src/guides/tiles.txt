Defold 2D Graphics - Tiles and Sprites
======================================

In 2D games, graphics are usually made up of a set of smaller images, which are either used just as they are, for flip-book animations or mapped out into levels or backgrounds.
For performance reasons, these images are often combined into one larger image, which is then used for many different purposes.
This is especially important to do on mobile devices.

In Defold, there are two types of assets that represents such a larger image.
The first is called link:http://en.wikipedia.org/wiki/Texture_atlas[atlas] and contains a list of image files, which will then be automatically combined into a larger image.
The second type is called a tile source (link:http://en.wikipedia.org/wiki/Tileset#Tile_set[tile set] and sprite sheet are other common names).
A tile source references an image file that contains sub-images ordered in a grid.

Importing Image Files
---------------------

The first thing you need to do to create graphics in Defold is to import the image files.
You can do this by simply dragging the files from the file system of your machine into the Project Explorer in Defold.
For the time being we only support the PNG format.

Atlas
-----

To create an atlas:

. Import your image files as described above
. Select *New* > *Atlas File* from the context menu in the Project Explorer.
. Select *Add Images* from the context menu in the Outline.
. Use the dialog to find and select the images you want to include.
  Note that you can filter the image files and select multiple files at once.

((((
image::images/tiles/atlas.png["Atlas editor", align="center"]
((((

Animations
~~~~~~~~~~

You can define animations of the sub-images in an atlas:

. Select *Add Animation Group* from the context menu in the Outline.
. Select *Add Images* from the context menu of the created anim-item and choose the images that represent the frames of the animation.
  Note that you can filter the image files and select multiple files at once.
  You can also reorder the images in the Outline.

Your atlas has now been populated with images (and animations) it can be used as a graphics source to other components in Defold (see link:#_sprite[Sprite] below and the link:particlefx[ParticleFX guide]).

Tile Source
-----------

To create a tile source in Defold, you first need the image containing the tiles.
All tiles must have the exact same dimensions and be placed in a grid.
We support spacing between the tiles and padding around each tile.
Examples could be an image containing the separate frames of player animations, an image containing the building blocks of the world, like wall-pieces or ground-pieces, or both.

Once you have the image, here is how you create a tile source:

. Add the image to your project by dragging it into the Project Explorer
. Create a new tile source
. Click the browse-button next to the image-field and select your image.
  The image will now be displayed in the editor.
. Tweak the width, height, margin and spacing to match your image.
  Correctly tweaked, the smaller images should appear exactly inside each cell of the transparent grid.

Collision Shapes
~~~~~~~~~~~~~~~~

Collision shapes for tile sets are generated using the alpha channel from the image specified in the collision field.
In many cases the same image can be used as both graphics and collision image.
When you specify a collision image, the preview is updated with an outline over the tiles.
By using a separate image, you can have collision shapes that differ from the visual graphics.

((((
image::images/tiles/tile_source.png["Tile Source editor", align="center"]
((((

Groups
^^^^^^

Collision groups are used to filter collisions in the game, you can read more about them in the link:/doc/physics[Physics guide].
All newly created tile sources contains a predefined collision group called +default+, which you can find in the Outline view.
You can add more groups from the Tile Set menu or the context menu of the Tile Source in the Outline.
To add the tiles to collision groups, select a group in the Outline and paint the tiles with your mouse.
The collision shapes will be colored according to which group they belong to.

Animations
~~~~~~~~~~

Flip-book animations consists of a set of tiles which correspond to each frame in the animation.
The tiles of each animation must lie next to each other in a sequence from left to right, but it's ok if they wrap and continue on the next line.
All newly created tile sources contains a predefined animation called +anim+, which you can find in the Outline.
You can add more animations just like collision groups described above.
Use the Properties view to specify how you intend the animation to play.
Name it to something that describes the animation, like +run_left+.
When you select an animation, its first frame is highlighted in the preview.
Click inside the preview and hit *Space* to play the animation.

Sprite
------

Sprite components are used to add flip-book animations to a game object.
They are typically used for characters and props.
This is how you create a sprite:

. Create (or open) the game object it should belong to
. From the Game Object context menu in the Outline, select *Add Component*
. Choose _Sprite_
. Specify which tile source and default animation it should use

The default animation is played when the game object is created and needs to be defined in the tile source you selected (see above how to do that).
To play different animations while the game is running, you post link:/ref/gamesys#play_animation[play_animation] to the sprite component.
Whenever an animation has finished playing, the message link:/ref/gamesys#animation_done[animation_done] will be sent back to the script that started the animation.

Example
~~~~~~~

Say that you have a game where the player should dodge while some input is held down (see the link:/doc/input[Input guide] how to set up the inputs).
You have four animations in your tile source called +idle+, +start_dodge+, +dodge_idle+ and +stop_dodge+.
+idle+ and +dodge_idle+ are looping animations of the player standing and dodging.
+start_dodge+ and +stop_dodge+ are play-once transition animations going from standing to dodging and from dodging to standing.
Here is what the script could look like to handle this:

[source-code, lua]
----
function on_input(self, action_id, action)
    -- "dodge" is our input action
    if action_id == hash("dodge") then
        if action.pressed then
            msg.post("#sprite", "play_animation", {id = hash("start_dodge")})
            -- remember that we are dodging
            self.dodge = true
        elseif action.released then
            msg.post("#sprite", "play_animation", {id = hash("stop_dodge")})
            -- we are not dodging anymore
            self.dodge = false
        end
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("animation_done") then
        -- one of the transition animations are finished, let's start looping
        if self.dodge then
            msg.post("#sprite", "play_animation", {id = hash("dodge_idle")})
        else
            msg.post("#sprite", "play_animation", {id = hash("idle")})
        end
    end
end
----

Attaching Physics
~~~~~~~~~~~~~~~~~

Sprites do not yet support the collision shapes generated in the tile source.
This feature will however come at a later time.
For the time being, you add collision objects with collision shapes like you would for any game object.
See the link:/doc/physics[physics guide] for more info.

Blend Mode
~~~~~~~~~~

Blend mode defines how the sprite should be blended with the graphics behind.
These are the available blend modes and how they are calculated:

* *Alpha* - Normal blending: +a~0~ * rgb~0~ + (1 - a~0~) * rgb~1~+
* *Add* - Brighten the background with the sprite: +rgb~0~ + rgb~1~+
* *Add Alpha* - Brighten the background with the visible parts of the sprite: +a~0~ * rgb~0~ + rgb~1~+
* *Multiply* - Darken the background with the sprite: +rgb~0~ * rgb~1~+

Sprite Shading
~~~~~~~~~~~~~~

The default sprite shading files are located under +/builtins/material/sprite.*+ in your project.
The default shading performs a regular texture lookup, but has also a tint (fragment shader constant) which is multiplied with the texture color.

To obtain other effects, like flashing a sprite white at hit-frames, you can implement your own custom shading.
To set a custom shading for your sprites, follow these steps:

. Copy the files +/builtins/material/sprite.*+ into one of your own directories (the files in the builtins-directory should never be modified). This is not mandatory but makes the process easier.
. Open +/your-directory/sprite.material+ and remap the shaders (.vp and .fp) to your own copies.
. Edit the .vp and .fp as you please. If you introduce shader constants, they must also be declared in the material file.
. Open your sprite and specify your new material in the properties.

To set shader constants while the game is running, use the functions link:/ref/gamesys#sprite.set_constant[sprite.set_constant] or link:/ref/gamesys#sprite.reset_constant[sprite.reset_constant].

Tile Maps
---------

A tile map is a component which lets you paint the tiles of a tile source over a large area in a grid-based fashion.
This is most commonly used to produce the environment of a level.
It can also use the collision shapes from the tile source for collision detection.

Painting Tiles
~~~~~~~~~~~~~~

. Open the tile map you want to paint in.
. Make sure there are no flagged issues in the Property or Outline views.
. Select a layer to paint into in the Outline.
. Select a tile to use (*Space* to show the palette).

((((
image::images/tiles/tile_map.png["Tile Map editor", align="center"]
((((

Picking Tiles
~~~~~~~~~~~~~

. Right-click (shift-click if you use the one-button mouse setup) and drag over the tiles you want to use.
. The blocks you selected can now be used as a brush.

Erasing Tiles
~~~~~~~~~~~~~

To select the eraser, you can either:

* Select it from the Tile Map menu
* Press backspace
* Select the active tile again in the palette
* Pick an empty cell in the tile map

Attaching Physics
~~~~~~~~~~~~~~~~~

. Open the tile source you connected to the tile map.
.. Make sure the tile source you connected to the tile map has an image set for collisions.
   They should be rendered as lines on top of the texture in the Editor view.
.. Make sure you have painted collision groups in the tile source for the tiles to support collision.
. Open the game object to which you have added the tile map.
.. Add a collision object component.
... Set its type to static.
... Add the collision group of the game objects you want it to collide with in its mask.
... Add the tile map as its shape.
. Open the other game objects you want to collide with the tile map.
.. Make sure they have collision objects. Check that the collision groups of the tiles are added to their masks.

Changing Tiles in the Game
~~~~~~~~~~~~~~~~~~~~~~~~~~

To change tiles in a tile map while the game is running, you post link:/ref/gamesys#set_tile[set_tile] to the tile map.

Texture Filtering and Sampling
------------------------------

There are two ways to sample a texture in Defold, _nearest_ and _linear_.
They differ in appearance whenever a texel (a pixel in a texture) is not perfectly aligned with a screen pixel.
This can happen if you have a moving camera, a moving sprite or you zoom in or out with the camera.

Nearest filtering means that the nearest texel will be picked to color the screen pixel.
This should be used whenever you want a perfect 1-1 pixel mapping from your textures to the screen.
If you use this you can’t really have any slow motions in your game as they would snap from pixel to pixel and look twitchy.
This is why nothing moves really slow in old school games like Super Mario Bros.

Linear filtering means that the texel will be averaged with its neighbors before coloring the screen pixel.
This produces a smoother appearance for slow continuous motions, as a sprite will bleed into the pixels before coloring them fully.
This should be used if you have dynamic collision objects, where slow speeds are common.
Another example is if you have smooth stops for objects or the camera.

The settings for which filtering to use are stored in the game.project file.
There are two settings: _min_ filtering and _mag_ filtering.
Min (minify) filtering applies whenever the texel is smaller than the screen pixel.
The reverse holds for mag (magnify) filtering.
They both accept the values +linear+ or +nearest+.
Below is an example of how to specify nearest for both.

----
[graphics]
default_texture_min_filter = nearest
default_texture_mag_filter = nearest
----

If you don’t specify anything, both are linear by default.

Linear Filtering and Edge Bleeding
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you use linear filtering and a tile source where each tile lies immediately next to the others (no borders), there is a risk you will experience edge bleeding.
If a neighboring tile has colored pixels on its edges, they might appear from time to time at the edges of your tiles, distorting the graphics.
The easiest solution to this is to make a transparent border between the tiles in the texture.
You then make sure that no tiles will bleed over to the other ones when doing this kind of sub-pixel sampling.
A better solution is to extend each tile with a border of pixels which are identical to the ones at the edges.

We are currently looking at different ways to solve these problems in the engine, so you don’t have to.
Until we find solutions we are happy with, you will have to manually fix your textures for this problem to go away.
