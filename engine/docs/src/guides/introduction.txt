Welcome to Defold!
==================

This introduction describes some basic concepts in our platform, the most important features and how the editor works.

Concepts
--------

Let's start with explaining some of the concepts to share our view of game development.
We recommend that you give it a glance even if you are an experienced game developer, since we might have different views.

Game Objects
~~~~~~~~~~~~

Game worlds consist of game objects.
Everything you can see or interact with is a game object.
A player avatar, a fired projectile, enemies, decorations and graphical user interfaces are different examples.
A game object works like a blueprint and can be cloned into multiple copies.
When you modify the blueprint, all copies are updated automatically.

((((
image::images/engine/blueprint.png["Game Object", align="center"]
((((

Components
~~~~~~~~~~

Components are used to extend game objects with functionality, e.g. graphics, sounds, collisions or behaviour.
A component can't exist by itself, it always needs a game object to be present in the game.
You can think of a game object as linking its components into the game.
Components are usually defined in the same files as the game objects.
If you want to reuse a component among several game objects, you can put it into a separate file.
This file can then be referenced from the different game object files.

((((
image::images/engine/components_2.png["Components", align="center"]
((((

Messages
~~~~~~~~

Components communicate with each other and other systems through message passing.
Messages are used to notify components that something should happen, e.g. hide graphics, turn off collisions or play a sound.
Everything in the game has an address, a URL (similar to how the web works).
This means that messages can be sent between any two components present in the game, whether or not they belong to the same game object.

Collections
~~~~~~~~~~~

A collection contains positioned game objects.
They are most commonly used to build levels.
Collections can contain other collections, which are then called sub-collections.
This allows you to reuse recurring game object setups at different locations in your level, like an enemy carrying a power-up item.

This is an example of how a common game scenario can be constructed.
We have two players, each controlling a space ship.
At the top of the screen, their different scores are displayed.

((((
image::images/engine/level.png["Level", align="center"]
((((

Factories
~~~~~~~~~

When a collection is loaded in the game, all the game objects it contains will be created and end up at their specified positions.
If you want to add game objects on the fly during the game, you can use a factory component.

((((
image::images/engine/factory.png["Factory", align="center"]
((((

Each factory has a reference to the game objects it can create.
To make it create more game objects, send it a message:

[source,lua]
----
msg.post("#factory", "create", {position = some_position, rotation = some_rotation})
----

where +factory+ is the identifier of the factory component attached to the game object and +create+ is the message the factory component responds to.
The +position+ and +rotation+ parameters lets you tell the game where and how you want the game object to end up when created.

Scripting
~~~~~~~~~

All scripts in Defold are written in the Lua programming language.
They let you specify the rules of your game, like how game objects should interact and respond to player input.
We have extended Lua with functions and messages, which are explained in the link:#!reference:engine[reference manual].
It also contains example code of how to use them from your scripts.

Lua in itself comes with many great features.
Please see the documentation on the link:http://www.lua.org[Lua site] and on the link:http://lua-users.org/wiki/LuaDirectory[Lua wiki].

The actual Lua-code to play an explosion sound of a game object can look like this:

[source,lua]
----
msg.post("#explosion", "play_sound")
----

where +explosion+ is the identifier of the sound component attached to the game object and +play_sound+ the message the sound component responds to.
When scripting, remember that no data is shared among the scripts.
Components (including scripts) only exchange information through message passing (by using the function link:#!reference:script/msg.post[+msg.post+]).

Collaboration
~~~~~~~~~~~~~

Very few people can make games by themselves.
We think the ability to work together is key for a fast development cycle.
This is why we have tried to make collaboration a corner stone of the Defold platform.

((((
image::images/engine/collaboration.png["Collaboration", align="center"]
((((

When you create a new project, a central repository is automatically created on our servers.
During development, the files you create and modify are actually a personal view of this repository.
When you are ready to share your changes, you can synchronize your personal view with the central repository from inside the editor.
This allows other members to receive your changes and you to receive any changes from them.
The changes are recorded and available as a history of what's happened in your project.
Backup or emailing files back and forth won't be necessary.

Common Building Blocks
----------------------

These are the most common building blocks used when creating a game.

Game Object
~~~~~~~~~~~

image:images/icons/brick.png["Game Object"]

Game objects are blueprints which describe the types of elements that make up your game, e.g. player avatars, enemies, weapons and power-ups.

Collection
~~~~~~~~~~

((((
image::images/icons/bricks.png["Collection"]
((((

A collection defines which game objects should appear where.
They can be used for many things, from large levels to small recurring sets of game objects.

Script
~~~~~~

image:images/icons/cog.png["Script"]

A script component defines the behavior of a game object, like how it should move around in the game world.
They can also define how the user can control it through input and how the other components in the game object should behave.
An example of this can be to turn on some special effect whenever the player is invulnerable.

Sound
~~~~~

image:images/icons/sound.png["Sound"]

The sound component is responsible for playing a specific sound.
Currently only wav-files are supported.

Collision Object
~~~~~~~~~~~~~~~~

image:images/icons/weight.png["Collision Object"]

Collision objects are components that extend game objects with physical properties and how they should collide with other game objects.
The most common types of collision objects are kinematic and dynamic.
Basically, a kinematic collision object follows its game object around, where a dynamic makes its game object obey the laws of physics, like gravitation and forces.

Factory
~~~~~~~

image:images/icons/factory.png["Factory"]

A factory is a component that can create other game objects in the game world on the fly.
They can be used to make enemies or power-ups appear when the game is running.

Tile Source
~~~~~~~~~~~
image:images/icons/small_tiles.png["Tile Source"]

A tile source describes a texture that is composed of multiple smaller images.
You can define animations of the smaller images in the tile source.
It can also calculate collision shapes automatically from image data.
They are used by the sprite and tile map components to share graphics resources.

((((
image::images/editor/tileset.png["Tile Source", align="center"]
((((
((((
image::images/editor/tile_set_hull.png["Tile Source", align="center"]
((((

Sprite
~~~~~~

image:images/icons/pictures.png["Sprite"]

A sprite is a component that extends game objects with graphics.
It displays one of the smaller images of a tile source and have built-in support for flip-book-animation.
It is usually used for characters and items.

Tile Map
~~~~~~~~

image:images/icons/layer_grid.png["Tile Map"]

Tile map components display images from a tile source in a grid based fashion.
It is most commonly used to build the environment of the game world, e.g. ledges in a platform-game or obstacles in an RTS-game.
It also supports automatic generation of collision shapes based on the images.
The displayed images can be changed to visualize changes in the game world, like a ledge being destroyed.

((((
image::images/editor/tilegrid_1.png["Tile Map", align="center"]
((((
((((
image::images/editor/tilegrid_2.png["Tile Map", align="center"]
((((

Gui
~~~

image:images/icons/text_allcaps.png["Gui"]

A gui component contains different elements used for user interfaces, like texts and textured blocks.
The elements can be animated and are typically used for Heads-Up Displays, menu systems and notifications for the users.
It uses a gui script, which defines the behaviour of the Gui and how the user can interact with it.

((((
image::images/editor/gui.png["Gui", align="center"]
((((

Gui Script
~~~~~~~~~~

image:images/icons/cog.png["Script"]

Gui scripts are used to define the behaviour of gui components.
This include how the user can interact with them, how information such as score and lives are presented as well as animations when specific events occur.

Font
~~~~

image:images/icons/font.png["Font"]

Fonts are based on a TrueType Font-file.
They specify which font size to use and what type of decoration (outline and shadow) it should have.
They are used by the gui components.

((((
image::images/editor/font.png["Font", align="center"]
((((

Input Binding
~~~~~~~~~~~~~

image:images/icons/keyboard.png["Input Binding"]

Input binding files define how the game should interpret hardware input (e.g. keyboard/mouse, touch pads and game pads).
In short, you define high-level input actions, like "jump", "move_forward", etc, which are then mapped to hardware input.
You can then take action on the high-level input in the Lua-scripts, without having to consider which hardware was actually used.

((((
image::images/editor/input_binding.png["Input Binding", align="center"]
((((

Other Building Blocks
---------------------

Camera
~~~~~~

image:images/icons/camera.png["Camera"]

Camera components helps to decide what part of the game world should be visible and how it should be projected.
A common example is to attach a camera to the player game object, or having a separate game object with a camera that follows the player around.

Material
~~~~~~~~

image:images/icons/large_tiles.png["Material"]

Materials define how different objects should be rendered by specifying shaders and their properties.

Render
~~~~~~

image:images/icons/paintcan.png["Render"]

Render files contains settings used when rendering the game onto the screen.
They define which Render Script to use for rendering and the different materials to use for things such as post effects.

Render Script
~~~~~~~~~~~~~

image:images/icons/cog.png["Render Script"]

A render script controls how the game should be rendered to the screen.
The default render script should cover the most common cases, but you can write your own for custom lighting models and other effects.

Collection Proxy
~~~~~~~~~~~~~~~~

image:images/icons/bricks_proxy.png["Collection Proxy"]

A collection proxy can be used to load and present collections on the fly during a game.
The most common example would be that you want to start your game as fast as possible without loading any level-data.
You can then use collection proxies to load and start your levels at a later time.

Editor Overview
---------------

The editor contains almost all the tools necessary to make your games, except graphics and sound editing.
The different areas are described in the image below.

((((
image::images/editor/editor.png["Editor Overview", align="center"]
((((

*File > Open Project* is the place to start.
When you have selected your project, you also need to create a branch.
A branch is like a personal view of your project.
To share the content you make with the other members in your project, use *File > Synchronize*.
This also updates your own branch with any changes made by the others.

The Project Explorer, Outline and Changed Files views have different context menus you should check out.
The main menu is also updated to reflect your current selection, so keep an eye on that too.

To use and navigate in the Scene Editor, which is the center area in the overview image above, we use key bindings similar to Maya.

* Use your mouse and keyboard modifiers to navigate.
* Windows/Linux: Alt+Middle Mouse Button and Alt+Right Mouse Button
  - Mac: Alt+Mouse Button and Alt+Ctrl+Mouse Button
  - Hold down Shift to select multiple objects.
* When an object is selected, you can activate different manipulators for that object in the Scene menu.

The Editor checks for updates automatically at start-up.
Each time we release a new version, we post a thorough description of the changes in the blog.

Let's get to work!
------------------

We recommend you follow the link:#!tutorials:side_scroller[Side-Scroller Tutorial] now to see what our platform is like in practice.
For more information, please see the link:#!documentation:[documentation page] (the tutorial is available there as well).
